<!DOCTYPE html>
<html>
<head>
    <title>Borm server</title>
    <link rel="stylesheet" href="styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
    @media screen and (max-width: 767px) {
      /* Styles for screens with a maximum width of 767px (i.e. mobile devices) */
      a {
        font-size: 16px;
        line-height: 1.5;
      }
      #container {
        width: 30%;
      }
    }



</style>
</head>
<body>

  <div id="top-bar">
    <a href="https://github.com/brammelam" id="link1">GitHub</a>
    <a href="https://linkedin.com/in/bramvanoostrum" id="link2">LinkedIn</a>
  </div>
  <div id="container">
  <p>
    <a href="index.html">Home</a><br>
    <a href="https://brammelam.github.io/tiny-racers-web">Tiny Racer</a><br>
    <a href="main.py">Bussruta</a>
  </p>
</div>

<script type = "module">
  const pixelRatio = window.devicePixelRatio || 1;

  const width = window.innerWidth;
  const height = window.innerHeight;
  // set up scene and camera
  var scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x000000 );
  var camera = new THREE.PerspectiveCamera( 75, width / height, 0.1, 1000 );
  camera.position.z = 30;
  // create a renderer
  var renderer = new THREE.WebGLRenderer({ antialias: true });
  // set the size of the renderer and add it to the DOM
  renderer.setSize(width, height);
  renderer.outputEncoding = THREE.sRGBEncoding;
  document.body.appendChild(renderer.domElement);
  const hemiLight = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
  hemiLight.position.set( 0, 400, -100 );
  hemiLight.intensity = 0.4;
  scene.add( hemiLight );

  const dirLight = new THREE.DirectionalLight( 0xffffff );
  dirLight.position.set( 0, 300, 300 );
  dirLight.intensity = 0.6;
  dirLight.castShadow = true;
  dirLight.shadow.camera.top = 180;
  dirLight.shadow.camera.bottom = - 180;
  dirLight.shadow.camera.left = - 180;
  dirLight.shadow.camera.right = 180;
  scene.add( dirLight );

  // Get the WebGL canvas element
  const canvas = renderer.domElement;
  const ctx = canvas.getContext('2d');
  // Set up touch event listeners
  let startY, endY;
  canvas.addEventListener('touchstart', (event) => {
      startY = event.touches[0].clientY;
  });
  canvas.addEventListener('touchmove', (event) => {
      endY = event.touches[0].clientY;
  });
  canvas.addEventListener('touchend', () => {
      // Check if the user has pulled down at least 100px
      if (endY - startY > 100) {
          // Reload the page to trigger a refresh
          location.reload();
      }
  });

  let mouseX = 0;
  let mouseY = 0;
  let deviceOrientationControls = null;

  // Detect if the device supports DeviceOrientation controls
  if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      // Request permission to use the device orientation controls
      DeviceOrientationEvent.requestPermission()
      .then(permissionState => {
          if (permissionState === 'granted') {
              // Create DeviceOrientation controls
              deviceOrientationControls = new THREE.DeviceOrientationControls(camera);
          }
      })
      .catch(console.error);
  } else {
      console.error('DeviceOrientation controls are not supported on this device');
  }

  window.addEventListener('mousemove', (event) => {
  const mouseX = event.clientX;
  const mouseY = event.clientY;

  const horizontalParallax = (mouseX - (window.innerWidth / 2)) / 100 * -1;
  const verticalParallax = (mouseY - (window.innerHeight / 2)) / 100 * -1;

  camera.position.x += (horizontalParallax - camera.position.x) * 0.15;
  camera.position.y += (verticalParallax - camera.position.y) * 0.1;
});

  // Add a listener for the window's resize event
  window.addEventListener("resize", onWindowResize);

  function onWindowResize() {
      // Update the renderer's size to match the new window size
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);

      // Update the camera's aspect ratio to match the new canvas size
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
  }

  const dotCount = 15; // or any other value you want
const dotPositions = [];
const dots = [];

let previousRotation = 0;

function checkCollision(dot, position) {
  // check if the new position overlaps with any existing dot
  for (let i = 0; i < dotPositions.length; i++) {
    const distance = dot.position.distanceTo(dotPositions[i]);
    const minDistance = dot.geometry.parameters.radius + dots[i].geometry.parameters.radius;
    if (distance < minDistance) {
      return true;
    }
  }

  // check if the new position is outside the visible area
  if (Math.abs(position.x) > 35 || Math.abs(position.y) > 35) {
    return true;
  }

  return false;
}
for (var i = 0; i < dotCount; i++) {
  var size = Math.random() * 4 + 1;
  var dotGeometry = new THREE.SphereGeometry(size, 7, 7);
  var hue = Math.floor(Math.random() * 40 + 180);
  var saturation = Math.floor(Math.random() * 10 + 90);
  var lightness = Math.floor(Math.random() * 40 + 20);


  var dotMaterial = new THREE.MeshStandardMaterial({ color: `hsl(${hue}, ${saturation}%, ${lightness}%)`, flatShading: true });
  var dot = new THREE.Mesh(dotGeometry, dotMaterial);
  var position = new THREE.Vector3();
  var collision = true;
  var attempts = 0;
  var maxAttempts = 10; // or any other value you want

  // try different positions until there is no collision
  while (collision && attempts < maxAttempts) {
    position.set(
      Math.random() * 70 - 35,
      Math.random() * 70 - 35,
      Math.random() * 20 - 10
    );
    collision = checkCollision(dot, position);
    attempts++;
  }

  if (!collision) {
    dot.position.copy(position);
    dot.speed = (Math.random() * 100)/ 10000;
    dots.push(dot);
    dotPositions.push(position);
    scene.add(dot);
  } else {
    console.log("Could not find a non-colliding position for dot ", i);
  }
}
  
  window.addEventListener("deviceorientation", event => {
  const beta = event.beta;
  const gamma = event.gamma;

  const currentRotation = Math.round(beta);

  
    // Calculate the parallax amount based on the device's orientation
    const horizontalParallax = gamma / 10;
    const verticalParallax = beta / 10;

    // Update the camera's position based on the parallax amount
    camera.position.x += (horizontalParallax - camera.position.x) * 0.2;
    camera.position.y += (verticalParallax - camera.position.y) * 0.2;
    previousRotation = currentRotation;
  
});

function animate() {
  requestAnimationFrame(animate);

  
  camera.lookAt(scene.position);

 
  

  dots.forEach((dot, index) => {
    dot.position.y -= dot.speed;
    if (dot.position.y < -50) { dot.position.y = 50;}
  });

  renderer.render(scene, camera);
}

animate();
</script>
  <div id="botpress-webchat"></div>
  <script src="https://cdn.botpress.cloud/webchat/v0/inject.js"></script>
  <script>
    window.botpressWebChat.init({
        "botId": "c67e4252-0ccc-4c57-ba96-c84e360324d8",
        "hostUrl": "https://cdn.botpress.cloud/webchat/v0",
        "messagingUrl": "https://messaging.botpress.cloud",
        "clientId": "c67e4252-0ccc-4c57-ba96-c84e360324d8",
        "botName": "CleverBot",
        "avatarUrl": "https://i.imgur.com/dR1ZDMK.png",
        "botConversationDescription": "I know everything",
        "showBotInfoPage": true,
        "containerWidth": "100%25",
        "layoutWidth": "100%25"
    });

  </script>

</body>
</html>
